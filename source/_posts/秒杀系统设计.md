---
title: 秒杀系统设计
author: MoMik
avatar: /images/author.gif
comments: true
abbrlink: 1233
date: 2019-01-01 11:01:07
categories:
tags:
keywords:
description:
cover:
---
## 秒杀需要解决的问题

1. 瞬时流量大
2. 恶意刷单
3. 超卖

**限流**：鉴于只有少部分用户能够秒杀成功，所以要限制大部分流量，只允许少部分流量进入服务后端。

**削峰**：对于秒杀系统瞬时的大量用户涌入，所以在抢购开始会有很高的瞬时峰值。实现削峰的常用方法有利用缓存或者消息中间件等技术；

**异步处理**：对于高并发系统，采用异步处理模式可以极大地提高系统并发量，异步处理就是削峰的一种实现方式；

**内存缓存**：秒杀系统最大的瓶颈最终都可能会是数据库的读写，主要体现在的磁盘的I/O，性能会很低，如果能把大部分的业务逻辑都搬到缓存来处理，效率会有极大的提升；



## 系统设计

![未命名文件 (1)](/Users/jieshi/Desktop/未命名文件 (1).png)

## 下单

![未命名文件 (3)](http://assets.processon.com/chart_image/5deef60be4b093b9f7763f78.png)

## #减库存方式

### 下单减库存

优势：用户体验最好。下单减库存是最简单的减库存方式，也是控制最精确的一种。下单时可以直接通过数据库事务机制控制商品库存，所以一定不会出现已下单却付不了款的情况。

劣势：可能卖不出去。正常情况下，买家下单后付款概率很高，所以不会有太大问题。但有一种场景例外，就是当卖家参加某个促销活动时，竞争对手通过恶意下单的方式将该商品全部下单，导致库存清零，那么这就不能正常售卖了——要知道，恶意下单的人是不会真正付款的，这正是 “下单减库存” 的不足之处。

### 付款减库存

优势：一定实际售卖。“下单减库存” 可能导致恶意下单，从而影响卖家的商品销售， “付款减库存” 由于需要付出真金白银，可以有效避免。

劣势：用户体验较差。用户下单后，不一定会实际付款，假设有 100 件商品，就可能出现 200 人下单成功的情况，因为下单时不会减库存，所以也就可能出现下单成功数远远超过真正库存数的情况，这尤其会发生在大促的热门商品上。如此一来就会导致很多买家下单成功后却付不了款，购物体验自然是比较差的。

### 预扣库存

优势：缓解了以上两种方式的问题。预扣库存实际就是“下单减库存”和 “付款减库存”两种方式的结合，将两次操作进行了前后关联，下单时预扣库存，付款时释放库存。

劣势：并没有彻底解决以上问题。比如针对恶意下单的场景，虽然可以把有效付款时间设置为 10 分钟，但恶意买家完全可以在 10 分钟之后再次下单。





## #系统接口

### #前端

#### 秒杀时间轴

##### 接口描述

| 接口名称 | timeLine           |
| -------- | ------------------ |
| 包名     | seckill            |
| 访问路径 | seckill/timeLine   |
| 接口描述 | 返回秒杀活动时间线 |

##### 请求参数

无

##### 响应结果

| 序号 | 英文名称     | 中文名称     | 类型    | 是否为空 | 备注 |
| ---- | ------------ | ------------ | ------- | -------- | ---- |
| 1    | timePoint    | 时间点       | String  | N        |      |
| 2    | isInProgress | 是否在进行中 | boolean | N        |      |

##### 报文

```json
[
    {
        "timePoint": "10:00",
        "isInProgress": true
    },
    {
        "timePoint": "12:00",
        "isInProgress": false
    },
    {
        "timePoint": "14:00",
        "isInProgress": false
    },
    {
        "timePoint": "16:00",
        "isInProgress": false
    },
    {
        "timePoint": "18:00",
        "isInProgress": false
    }
]
```



##### 接口实现

1. 查询字典表中配置的秒杀时间节点

2. 获取当前系统时间判断当前时间处于哪个时间轴点上

3. 去除过时的时间节点

#### 系统对时接口

##### 接口描述

| 接口名称 | systemTime         |
| -------- | ------------------ |
| 包名     | seckill            |
| 访问路径 | seckill/systemTime |
| 接口描述 | 返回当前服务器时间 |

##### 请求参数

无

##### 响应结果

| 序号 | 英文名称   | 中文名称       | 类型   | 是否为空 | 备注                                  |
| ---- | ---------- | -------------- | ------ | -------- | ------------------------------------- |
| 1    | systemTime | 服务器系统时间 | String | N        | 格式精确到毫秒yyyy-MM-dd HH:mm:ss SSS |

##### 报文

```json
{
    "systemTime": "2019-12-16 14:11:23 234"
}
```



##### 接口实现

1. 获取当前服务器系统时间
2. 格式化为上述格式返回

#### 秒杀商品列表

##### 接口描述

| 接口名称 | productList       |
| -------- | ----------------- |
| 包名     | seckill           |
| 访问路径 | seckill/goodsList |
| 接口描述 | 返回秒杀商品列表  |

##### 请求参数

| 序号 | 英文名称  | 中文名称 | 类型   | 是否为空 | 备注 |
| ---- | --------- | -------- | ------ | -------- | ---- |
| 1    | timePoint | 时间点   | String | N        |      |

##### 响应结果

>  使用分页显示

| 序号 | 英文名称     | 中文名称   | 类型   | 是否为空 | 备注 |
| ---- | ------------ | ---------- | ------ | -------- | ---- |
| 1    | goodsId      | 商品Id     | String | N        |      |
| 2    | title        | 商品标题   | String | N        |      |
| 3    | pic          | 商品缩略图 | String | N        |      |
| 4    | seckillPrice | 秒杀价     | String | N        |      |
| 5    | goodsPrice   | 原始价     | String | N        |      |
| 6    | surplusStock | 剩余库存   | int    | N        | 暂定 |
| 7    | stock        | 总库存     | int    | N        | 暂定 |
| 8    | progress     | 已售占比   | String | N        |      |

##### 报文

```json
[
    {
      	"goodsId": "201909060429",
        "title": "玛娜（MANA）水立方胶原喷雾150ml",
        "pic": "http://jscloud-shop.oss-cn-shanghai.aliyuncs.com/201909/37818d665f0e6ff5b6b0c477d13b829a.JPEG",
        "seckillPrice": 9.9,
        "goodsPrice": 100,
        "progress": "24%"
    }
]
```



##### 接口实现

1. 根据时间点获取商品列表（Redis）

   如果Redis中不存在，查询数据库中的商品并缓存至redis中

2. 根据总库存和剩余库存计算已售占比   已售占比 = (总库存stock-剩余库存surplusStock)/(总库存stock*100%)

#### 秒杀商品详情

##### 接口描述

| 接口名称 | goodsDetail          |
| -------- | -------------------- |
| 包名     | seckill              |
| 访问路径 | seckill/goodsDetail  |
| 接口描述 | 返回秒杀商品详情信息 |

##### 请求参数

| 序号 | 英文名称 | 中文名称 | 类型   | 是否为空 | 备注 |
| ---- | -------- | -------- | ------ | -------- | ---- |
| 1    | goodsId  | 商品编号 | String | N        |      |

##### 响应结果

| 序号 | 英文名称          | 中文名称                     | 类型   | 是否为空 | 备注 |
| ---- | ----------------- | ---------------------------- | ------ | -------- | ---- |
| 1    | goodsId           | 商品Id                       | String | N        |      |
| 2    | title             | 商品标题                     | String | N        |      |
| 3    | smallImages       | 商品主图列表                 | Array  | N        |      |
| 4    | seckillPrice      | 秒杀价                       | String | N        |      |
| 5    | goodsPrice        | 原始价                       | String | N        |      |
| 8    | progress          | 已售占比                     | String | N        |      |
| 9    | detailPics        | 图文详情图                   | Array  | N        |      |
| 10   | isFifteenExchange | 是否支持15天换货（Y/N）      | String | N        |      |
| 11   | isWeekReturn      | 是否支持7天无理由退货（Y/N） | String | N        |      |
| 12   | itemGetCoins      | 单品返派币                   | String | N        |      |
| 13   | itemGetPoints     | 单品返积分                   | String | N        |      |
| 14   | itemSpec          | 产品规格                     | String | N        |      |
| 15   | limited           | 商品单次限购数量             | int    | N        |      |
| 16   | suitableDesc      | 适用说明                     | String | N        |      |

##### 报文

```json

```

##### 接口实现

1. 根据商品Id查询商品详细信息（Redis）

#### 下单接口

#### 结果查询接口

##### 接口描述

| 接口名称 | buyResult          |
| -------- | ------------------ |
| 包名     | seckill            |
| 访问路径 | seckill/buyResult  |
| 接口描述 | 返回当前服务器时间 |

##### 请求参数

| 序号 | 英文名称   | 中文名称       | 类型   | 是否为空 | 备注 |
| ---- | ---------- | -------------- | ------ | -------- | ---- |
| 1    | systemTime | 服务器系统时间 | String | N        |      |

##### 响应结果

| 序号 | 英文名称 | 中文名称       | 类型   | 是否为空 | 备注 |
| ---- | -------- | -------------- | ------ | -------- | ---- |
| 1    | status   | 服务器系统时间 | String | N        |      |
| 2    | desc     | 结果描述       | String | N        |      |
| 3    | content  | 结果内容       | String | N        |      |

##### 报文

```json

```

##### 接口实现

1. 根据商品Id查询当前用户对该商品的下单结果（Redis）

   查询hash键seckill_mem_order_result_now根据key商品id获取value

   ```java
   RedisUtil.getRedisHashMapField("seckill_mem_order_result_now","2019....");
   ```

#### 补全订单接口

#### 获取会场口令接口

### #后端

1. 新增/修改/删除秒杀商品
2. 时间轴配置

## 订单超时未支付策略

1. 使用MQ的定时消息/延时消息机制（首选）

   通过监听延时消息检查当前订单是否已经支付，若未支付：释放库存。

2. 使用Redis过期key监听

   通过订阅监听功能对过期订单检查是否已经支付（实际上一般只可能是未支付订单才会到这里）

   >  弊端：

   - 1.后台服务不可用时，如果此时有key失效那么是监听不到的。（解决方法：项目启动时或定时任务补偿处理）
   - 2.redis重启或不可用时，导致业务无法处理。（解决方法：redis集群实现高可用）

3. 定时任务检查

   下单成功后新建一条xx分钟后执行的任务，到达指定时间后进行检查订单时候已支付，若未支付：释放库存





## 秒杀活动配置

动态口令配置

秒杀活动分享

